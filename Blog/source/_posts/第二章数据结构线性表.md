---
title: 第二章 数据结构线性表
date: 2018-10-06 16:07:40
categories:
- 算法
tags:
- 数据结构
---
## 一、线性表

### 1. 主要概念

- 线性表是数据结构中最简单的数据存储结构，可以理解为“线性的表”。
- 对于线性表中的数据来说，位于当前数据之前的数据统称为“前趋元素”，前边紧挨着的数据称为“直接前趋”；同样，后边的数据统称为“后继元素”，后边紧挨着的数据称为“直接后继”。
<!-- more -->
### 2.线性表的分类

- 数据元素在内存中集中存储，采用顺序表示结构，简称“顺序存储”；
- 数据元素在内存中分散存储，采用链式表示结构，简称“链式存储”。

### 3.顺序表的实现方法

#### 定义顺序表的结构

```C
typedef struct Table{
    int * head;//声明了一个名为head的长度不确定的数组，也叫“动态数组”
    int length;//记录当前顺序表的长度
    int size;//记录顺序表分配的存储容量
}table;
```

#### 其他操作
```
table addTable(table t,int elem,int add)
{
    if (add>t.length+1||add<1) {
        printf("插入位置有问题");
        return t;
    }
    if (t.length>=t.size) {
        t.head=(int *)realloc(t.head, (t.size+1)*sizeof(int));
        if (!t.head) {
            printf("存储分配失败");
        }
        t.size+=1;
    }
    for (int i=t.length-1; i>=add-1; i--) {
        t.head[i+1]=t.head[i];
    }
    t.head[add-1]=elem;
    t.length++;
    return t;
}
table delTable(table t,int add){
    if (add>t.length || add<1) {
        printf("被删除元素的位置有误");
        exit(0);
    }
    for (int i=add; i<t.length; i++) {
        t.head[i-1]=t.head[i];
    }
    t.length--;
    return t;
}
int selectTable(table t,int elem){
    for (int i=0; i<t.length; i++) {
        if (t.head[i]==elem) {
            return i+1;
        }
    }
    return -1;
}
table amendTable(table t,int elem,int newElem){
    int add=selectTable(t, elem);
    t.head[add-1]=newElem;
    return t;
}
void displayTable(table t){
    for (int i=0;i<t.length;i++) {
        printf("%d",t.head[i]);
    }
    printf("\n");
}
```

### 4.顺序表的有缺点

- 顺序表实现的基础，完全借用了数组这一数据类型，优点是在对数据进行遍历时，数据在连续的物理空间中存放，查找的速度比较快。

- 但是由于数组本身的限制，在向顺序表中新增或者删除数据元素时，如果被操作位置后续有很多数据元素，后续所有的数据元素都需要前移，最后虽然实现了功能，但是程序总体效率不高。


## 二、 链表（单链表）-动态链表

### 1.链表中数据元素的构成
- 本身的信息，称为“数据域”；
- 指向直接后继的指针，称为“指针域”。

这两部分信息组成数据元素的存储结构，称之为“结点”。n个结点通过指针域相互链接，组成一个链表。

### 2.头结点、头指针和首元结点

- 头结点：有时，在链表的第一个结点之前会额外增设一个结点，结点的数据域一般不存放数据（有些情况下也可以存放链表的长度等信息），此结点被称为头结点。
- 首元结点：链表中第一个元素所在的结点，它是头结点后边的第一个结点。
- 头指针：永远指向链表中第一个结点的位置（如果链表有头结点，头指针指向头结点；否则，头指针指向首元结点）。

### 3.总结
线性表的链式存储相比于顺序存储，有两大优势：
链式存储的数据元素在物理结构没有限制，当内存空间中没有足够大的连续的内存空间供顺序表使用时，可能使用链表能解决问题。（链表每次申请的都是单个数据元素的存储空间，可以利用上一些内存碎片）
链表中结点之间采用指针进行链接，当对链表中的数据元素实行插入或者删除操作时，只需要改变指针的指向，无需像顺序表那样移动插入或删除位置的后续元素，简单快捷。

链表和顺序表相比，不足之处在于，当做遍历操作时，由于链表中结点的物理位置不相邻，使得计算机查找起来相比较顺序表，速度要慢。

## 三、静态链表

### 1.静态链表中结点的构成
静态链表中每个结点既有自己的数据部分，还需要存储下一个结点的位置，所以静态链表的存储实现使用的是结构体数组，包含两部分： 数据域 和 游标（存放的是下一个结点在数组中的位置下标）。

```
typedef struct {
    int data;//数据域
    int cur;//游标
}component;
```

### 2.总结
静态链表综合了顺序表和动态链表的优点：使用数组存储数据元素，便于做查找遍历操作；同时，在数组中借鉴了动态链表的特点，在链表中插入或者删除结点时只需更改相关结点的游标，不需要移动大量元素。
