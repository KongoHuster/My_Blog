---
title: 第六章 面向对象
date: 2018-10-06 16:07:40
categories:
- Java学习
tags:
- Java
---

### 一、单例类

如果一个类始终只能创建一个对象，称为单例类。须符合以下几个条件：
- 1.我们把该类的构造器使用Private修饰，从而把该 类的所有构造器隐藏起来。
- 2.则需要提供一个public方法作为该类的访问点，用于创建该类的对象，且必须使用static修饰
- 3.该类还必须缓存已经创建的对象，必须用static修饰


### 二、接口

#### 1.接口概念
- 接口定义的是多个类共同的行为规范，这些行为是与外部交流的通道，这就意味着接口里通常是定义一组公用的方法。

#### 2.接口实现

- 一个类实现了一个或多个 接口之后，这个类必须完全实现这些接口里所定义的全部抽象方法（也就是重写这些抽象方法）；
- 否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。 

#### 3.接口和抽象类的相似性

- 接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。
- 接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。

#### 4 接口与抽象类的区别

- 接口里只能包含抽象方法，不同包含已经提供实现的方法；抽象类则完全可以包含普通方法。
- 接口不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而让其子类调用这些构造器来完成属于抽象类的初始化操作。
- 接口里不能包含初始化块，但抽象类则完全可以包含初始化块。

### 三、内部类

- 我们把一个类放在另一个类的内部定义，这个定义在其他类内部的类就被称为内部类，有的也叫嵌套类，包含内部类的类也被称为外部类有的也叫宿住类。
- 内部类提供了更好的封装，内部类成员可以直接访问外部类的私有数据，因为内部类被当成其他外部类成员。
- 匿名内部类适合用于创建那些仅需要一次使用的类。


### 四、非静态内部类

- 定义内部类非常简单，只要把一个类放在另一个类内部定义即可。
- 当在非静态内部类的方法内访问某个变量时，系统优先在该方法内查找是否存在该名字的局部变量，如果存在该名字的局部变量，就使用该变量，如果不存在，则到该方法所在的内部类中查找是否存在该名字的属性，如果存在则使用该属性

### 五、静态内部类

- 如果用static修饰一个内部类，称为静态内部类。
- 静态内部类可以包含静态成员，也可以包含非静态成员。所以静态内部类不能访问外部类的实例成员，只能访问外部类的类成员。
- 静态内部类的对象寄存在外部类里，非静态内部类的对象寄存在外部类实例里
- 使用静态内部类
```
private 修饰的内部类只能在外部类内部使用。
在外部类以外的地方使用内部类，内部类完整的类名应该OuterClass.InnerClass.
在外部类以外的地方使用非静态内部类创建对象的语法如下：OuterInstance.new InnerConstructor()
在外部类以外的地方使用静态内部类创建对象的语法如下：new OuterClass.InnerConstructer();
```

### 六、枚举类

- 枚举类也是一种类，只是它是一种比较特殊的类，因此它一样可以使用属性和方法
- 枚举类通常应该设计成不可变类，也就说它的属性值不应该允许改变，这样会更安全，而且代码更加简洁。为此，我们应该将枚举类的属性都使用private final修饰。
- 一旦为枚举类显式定义了带参数的构造器，则列出枚举值时也必须对应地传入参数。  
- 如果需要每个枚举值在调用同一个方法时呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法，每个枚举值提供不同的实现方式，从而让不同枚举值调用同一个方法时具有不同的行为方式。 


### 七、对象在内存中的状态

- 激活状态：当一个对象被创建后，有一个以上的引用变量引用它。则这个对象在程序中处于激活状态，程序可通过引用变量来调用该对象的属性和方法。
- 激活状态：当一个对象被创建后，有一个以上的引用变量引用它。则这个对象在程序中处于激活状态，程序可通过引用变量来调用该对象的属性和方法。
- 死亡状态：当对象与所有引用变量的关联都被切断，且系统会调用所有对象的finalize方法依然没有使该对象变成激活状态，那这个对象将永久性地失去引用，最后变成死亡状态。只有当一个对象处于死亡状态时，系统才会真正回收该对象所占有的资源。 

### 八、对象的软、弱和虚引用 

- 软引用－软引用需要通过SoftReference类来实现，当一个对象只具有软引用时，它有可能被垃圾回收机制回收。  
- 弱引用－弱引用通过WeakReference类实现，弱引用和软引用很像，但弱引用的引用级别更低。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。 
- 虚引用－虚引用通过PhantomReference类实现，虚应用完全类似于没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在

